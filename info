import re
import pandas as pd

# ========= CONFIGURE THESE =========
xlsx_path        = "path/to/workbook.xlsx"
sheet_name       = "Capital Movements"
row_actual_forecast = 2
row_date             = 3
first_data_row       = 8
# ===================================

def _parse_accounting_number(x):
    """'(1,234.5)' -> -1234.5 ; '1,234' -> 1234 ; '', '-', '–', '—' -> 0 ; '3.5%' -> 0.035 ; other text -> NA."""
    if pd.isna(x):
        return 0.0  # <- EDIT #1: empty cell counts as zero
    s = str(x).strip()
    if s in {"", "-", "–", "—"}:
        return 0.0  # <- EDIT #1: visibly blank placeholders => zero
    if s.endswith("%"):
        try:
            return float(s[:-1].replace(",", "")) / 100.0
        except ValueError:
            return pd.NA
    if re.fullmatch(r"\(\s*[\d,]*\.?\d*\s*\)", s):
        s = "-" + s.strip("()")
    s = s.replace(",", "")
    try:
        return float(s)
    except ValueError:
        return pd.NA  # non-numeric text (notes) -> NA so we can drop it

# ---------- (rest of the script is same up to tidy creation) ----------

raw = pd.read_excel(xlsx_path, sheet_name=sheet_name, header=None, engine="openpyxl")

idx_row_af = row_actual_forecast - 1
idx_row_dt = row_date - 1
candidate = raw.iloc[[idx_row_af, idx_row_dt], 4:]
non_empty_cols = candidate.apply(lambda col: col.notna().any(), axis=0)
if not non_empty_cols.any():
    raise ValueError("Couldn't find any non-empty header cells to the right of column D.")
first_value_col_abs = 4 + non_empty_cols.idxmax()

hdr_af = raw.iloc[idx_row_af, first_value_col_abs:].astype(object).ffill().map(lambda v: "" if pd.isna(v) else str(v).strip())
hdr_dt = raw.iloc[idx_row_dt, first_value_col_abs:].astype(object).ffill().map(lambda v: "" if pd.isna(v) else str(v).strip())
multi_cols = pd.MultiIndex.from_arrays([hdr_af.tolist(), hdr_dt.tolist()], names=["ActualForecast","Date"])

id_block = raw.iloc[first_data_row-1:, 0:4].copy()
id_block.columns = ["Key","CorepReference","DetailedCapitalTable","CapitalTableReference"]

val_block = raw.iloc[first_data_row-1:, first_value_col_abs:].copy()
val_block.columns = multi_cols

all_df = pd.concat([id_block, val_block], axis=1)
# drop spacer rows that are completely empty across IDs and values
all_df = all_df.dropna(how="all")

tidy = (
    all_df
    .set_index(["Key","CorepReference","DetailedCapitalTable","CapitalTableReference"])
    .stack(list(range(len(multi_cols.names))))
    .reset_index()
)
tidy.columns = ["Key","CorepReference","DetailedCapitalTable","CapitalTableReference","ActualForecast","Date","Value"]

# parse numbers; blanks become 0, genuine nonnumeric text becomes NA
tidy["Value"] = tidy["Value"].apply(_parse_accounting_number)

# EDIT #2: drop only rows where Value is NA *after parsing* (i.e., notes or text),
# but keep zeros created from blanks.
tidy = tidy[tidy["Value"].notna()].reset_index(drop=True)

for c in ["Key","CorepReference","DetailedCapitalTable","CapitalTableReference","ActualForecast","Date"]:
    tidy[c] = tidy[c].astype(str).str.strip()

# tidy.to_csv("CapitalMovements_tidy.csv", index=False)
print(tidy.head(20))